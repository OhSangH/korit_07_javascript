# JavaScript 개발환경 구성

1. vs code
2. Node.js
   - 서버프로그램 개발을 자바 스크립트로가능하도록 하는 자바스크립트 런타임 환경
   - 원래 자바스크립트는 웹 브라우저에서 동작하는 언어인데 개발환경을 구성하기 위한 것

# JavaScript

## JavaScript 작성 위치

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript 코드의 작성 위치</title>
    <script>
      // 1. 첫 번째 위치로 head 태그 내에 script 태그를 생성하여 태그 안에 작성 가능하다.'
      document.write("자바 스크립트 head 태그에 위치 <br>");
      //
    </script>
    <script src="./01_ja_location.js"></script>
  </head>
  <body>
    <script>
      // 2. 두 번째 위치로 body 태그 내에 script태그를 생성하여 코드 작성이 가능하다.
      document.write("자바 스크립트 body 태그에 위치 <br>");
      // 3. 01_ja_location
    </script>
    <script src="./01_ja_location.js"></script>
  </body>
</html>
```

1. 첫 번째 위치로 head 태그 내에 script 태그를 생성하여 코드 작성이 가능하다.
2. 두 번째 위치로 body 태그 내에 script 태그를 생성하여 코드 작성이 가능하다.
3. 세 번째 위치로 .js 파일을 생성 후 js코드를 작성이 가능하다.

- 참고 : 확장 프로그램 Code Runner
  - 자바 스크립트를 콘솔창에 실행 결과를 출력 가능
  - 문제점은 html과 연동해서 읽는 거잇 아니라 .js파일 차체만 읽ㄱ기 때문에 임시 방편이고, 미리보기의 경우 개발자 도구를 확인할 수 없기 때문에 console.log를 확인 할 수 없다.
  - console과 document를 둘 다 사용하는 경우에는 Live Server를 활용할 수 밖에 없다.

console 객체의 .log 메서드와 document 객체의 .write 메서드를 확인 했다.

## 변수와 상수

1. 변수(variable) : 데이터를 담는 그릇 Js에서는 변수에 리터럴 뿐만이 아니라 객체도 담을 수 있고, 함수도 담을 수 있다.
2. 상수(const) : 변화하지 않는 데이터 값을 가지고 있는 변수

### 변수 선언 형식

```
형식
선언자 변수명 = 데이터;
```

위의 방식으로 선언 된다.

```js
var greeting = "hello, javascript";
```

- Js 변수 선언 규칙

1. 변수명은 문자(특수문자 제외), 숫자 , \_(언더스코어), $(달러 기호)를 포함하여 만들 수 있다.
2. 변수명은 숫자로 시작할 수 없다.
3. Js 예약어(기본적으로 JS에서 정의되어 사용되는 단어들)는 사용할 수 없다
4. 대소문자를 구분한다.
5. 스크립트 표준안 ECMA Script에서는 변수명 / 함수명은 카멜 케이스를 사용사고 클래스명, 생성자 명에는 파스칼 케이스를 사용할 것을 권장한다.

### var 선언자

Js 상에서는 데이터 타입(자료형)에 관계 없이 변수를 저장할 때 var 선언자와 let 선언자를 사용할 수 있다.  
실무에서는 기본적으로 let을 사용한다. 그러나 부산에서는 var를 사용한다.

```js
var x = 5;
var y = 6;
var z = x + y;
```

위를 확인하면 선언시 var를 사용 하면 되겠지만

```js
var x = 5;
var y = 6;
var z = x + y; // 11이 저장된다.

var x = 7;
z = x + y; // 13이 저장 될 것이다.
```

위 라인에서는 x는 재선언 했고 z는 선언 없이 사용하였다.  
그러나 코드를 실행하면 둘 다 에러 없이 동작이 된다.  
이러한 경우 생기는 문제는 동일한 변수명에 전혀 다른 기능을 넣었을때, 테스트 하는 과정에 java처럼 컴파일 에러가 발생하는 것이 아니라 동작되기 때문에

```js
console.log(a); // 출력 : undifined
var a = 10;
console.log(a); // 출력 : 10
```

그리고 위의 코드라인도 오류가 발생 하지 않는다. 추후 hosting개녕르로 설명 할 예정이다.
하지만 이미 많은 웹 사이트들이 var 사용하여 코드를 작성해서 현재 서비스가 진행중이기 때문에 var 갑자기 금지시키는 것은 불가능하고, 그래서 ES6부터는 let이라는 선언자를 추가로 만든 후에, 이를 사용하는 쪽을 권장하는 방식으로 개선이 이루어지고 있다.

### let 선언자

ES6 이후 추가된 선언자로, 성능은 var와 동일하다. 하지만 var의 문제점을 해결하기 위해 등장했기 때문에 Java를 배운 사람 한테는 원시자료형을 let으로 사용하면 된다.

1. 재대입 할 때 오류가 발생 한다.
2. 순서대로 실행되기 때문에

```js
console.log(a); // 오류 발생
let a = 10;
console.log(a);
```

와 같은 방식으로 작성하면 오류가 발생한다.

### const 선언자(상수)

마찬가지로 ES6에 추가된 선언자로, 상수(constant)는 변화하지 않는 변수를 의미한다.  
java에서는 final을 보통 사용하지 않았던 방면 Js에서는 웨만하면 const를 쓰라고 권장한다. 그래야만 절대로 값이 변경되지 않으니 웹 서비스가 안정되기 때문이다. 그러나 웹서비스상에서 유연성이 없나 않지만 또 그렇지 않다.

```js
const x = 3;
const y = 4;
const z = x + 7;

x = 5; // 오류발생
```

그럼 const는 어떨 때 쓰이냐, 애플리케이션 내에 날짜를 보여주는 화면이 있다고 가정을 했을 때

1. 20250827
2. 2025-08-27
3. 2025/08/27
4. 2025.08.27

등을 예시로 들 수 있다. 그런데 특정 페이지에서는 1번 방법이고 다른 페이지에서는 3번 방법을 사용하진 않을 거고 동일한 웹스비스 내라면 하나의 양식으로 날짜를 출력할 것이다.
이러한 경우에 const를 선언합니다.

```js
const DATE_FORMAT = "yyyy-mm-dd"; // 와 같은 방식
```

## 데이터 타입

### 기본 자료형

1. string
2. number (정수, 실수를 포함한 숫자)
3. boolean
4. undefined
5. null
6. symbol

#### sting

Java 와는 다르게 ''(작은 따음표)를 쓸 예정이다.

```js
console.log("제 이름은 '안근수'입니다");
console.log('오늘 제 점심은 "짜장면"');
```

사용은 큰 따옴표와 작은 따옴표 둘다 사용이 가능하다. 문자열 내부에 따옴표를 쓸 일이 있으면 반대 따옴표로 작성 하면 된다.

#### number

java의 원시 자료형중 실수형과 정수형을 모두 합한거ㅣ

#### boolean

true/false를 표시한다.

#### undefined

- 자료형이면서 동시에 데이터 값이다. -> 정의되지 않음. 을 의미하고 , 변수를 선언하고 아무런 값을 할당 하지 않으면 undefined가 출력된다.

#### null

- null도 undefined처럼 자료형 이ㅏ면서 데이터 값에 해당하는데, 둘 다 변수에 값이 없는 상태를 의미하낟.
- nudefined는 웹 브라우저 상에서 JS를 실행 할 때 값이 할당 되지 않은 변수에 대해서 자동으로 리턴 해주는 것에 반해 null의 경우는 개발자가 평가해서 사용한다.
- 선언된 변수에 대해서 아직 어떤 값을 할당할지 모르거나 어떤 데이터 타입이 할당 될 지 모르는 경우에 _개발자가 명시적_ 으로 null값을 대입해 두는 겂을 의미한다.
- 변수에 null을 할당하면 변수가 이전에 참조하던 값을 더 이상 참조 하지 않게 되기 때문에 메모리 효율성이 향상됩니다. 자바의 가비지 컬렉터처럼 JS도 일정 주기 마다 메모리 공간을 확보 하는데 이때 null값이 할당 되 있으면 해당 변수에 대해 참조를 해제한다.

#### symbol

- ES6에 추가된 새로운 자료형으로, 추후 설명 예정이다.

### 객체(Object)

- 추후 더 자세히 설명하기 하겠지만 자료형의 개념으로서의 Object에 대해서 설명하면, JS의 모든 것은 객체로 이루어져 있다. 하지만 데이터 관점에서 사용하는 것은 Object와 Array입니다.

예시

```js
const person = {
  firstName: "Jone",
  lastName: "doe",
  age: 20,
  eyeColor: "bule",
};
```

앞부분이 key고 뒷부분이 value이다. 그리고 js의 키-밸류를 property라고 부는다.

수정방법

```js
// 객체의 property수정 방법 1
person.firstName = "일"; // 이건 자바에서의 필드 수정방법
person.lastName = "김"; // access modifier 배우기 이전
console(person);

// 객체의 property 수정 방법 2
person["eyeColor"] = "검은색"; // 이건 Map에서 수정방법
console.log(person);
```

#### Array(배열)

하나 이상의 데이터를 하나의 변수에 관리하기 위한 방법으로, 이를 굳이 풀어 쓰면 하나의 단일 참조(single refernce)를 통해 다수 값을 확인 가능하는 구조입니다. 배열에 저장된 데이터의 특징은 _순서_ 를 갖는다는 것이다.

형식

```js
const cars = ["hyundai", "kia", "ford", "nissan"];
```

와 같은 형식으로 작성한다.  
자바와의 차이점으 {}이냐[]로 둘 수 있다.

출력하는 방법

```js
console.log(cars[0]);
```

로 출력한다.

element 값 바꾸는 방법

```js
cars[1] = "Honda";
console.log(cars[1]);
```

### typeof 연산자

자자는 처음 변수 선언할 때 자료형을 명시하기 때문에 필요 없는 개념에 가깝지만 , JS의 경우 어떤 변수에 어떤 자료형이 들어가있는지 모르기 때문에 확인하기 위한 연산자 입니다.

```js
let x = "안녕";
let y = 30;

// typeof사용법
console.log(typeof x); // string
console.log(typeof y); //int

console.log(typeof { x: 1, y: 2 }); // object
console.log(typeof [1, 2, 3]); // object
console.log(typeof null); // object
```

JS에서는 배열도 object에 해당한다.

## 연산자

### 할당 연산자

- 연산 결과를 = 왼쪽에 있는 변수에 대입할 때 사용하는 연산자들로,  
  +,-,\*,/,% 까지는 자바와 동일하다.
  근데 \*\*가 있다.

- \*\* 지수 할당 연산자

  ```js
  let x = 2;
  let y = 3;

  z = x ** y; // 2의 3제곱을 의미한다.
  console.log(z);
  ```

#### 복합 연산자

+=, -=, \*=, /=, %=, \*\*=

```js
let x = 3;
let y = 2;
console.log((x %= y)); // x = x % y = 3 % 2

let a = 2;
let b = 5;
console.log((a **= b)); // a = a ** b = 2^5 = 32
```

### 비교연산자

```js
let a = 3;
let b = "3";

console.log(a == b); // true
console.log(a === b); // false
```

Js에서는 서로 다른 자료형일 때도 비교하는 것이 가능한데 String과 number를 비교하더라고 자료형 제뢰하고 내부 데이터 값만 비교해서 true를 도출하는경우가 있다.

`==` : a 와 b의 값이 같은지를 비교함. 정확하게는 String인 b를 number를 바꿔서 비교하고 true 리턴
`===` : a 와 b의 값 뿐만 아니라 자료형 까지 비교

### 산술 연산자

++, -- 가 있다.

### 논리 연산자

&& : AND  
|| : OR  
! : Not

### 문자열 연산자

`+`만 적용됨

### 삼항 연산자

형식

```
(조건) ? 값1 : 값2;
```

위 형식이다.

```js
let age = 18;
letisAdult = age >= 20 ? true : false;

// 심화 (중첩 삼항 연산자)
let point = 92;
let grade = point >= 90 ? "A" : point >= 80 ? "B" : "C";
```

#### 조건문

- if문(if / else if / else 포함해서 한꺼번에 하겠습니다)
  02_condition.html / 02_condition.js

switch문 03_condition_switch.html / 03_condition_switch.js 참조 작성방식은 Java와 같습니다.

#### 반복문

- 반복문은 조건을 만족하는 동안 코드 블록을 반복적으로 수행합니다.
- Js에서는 for / for-in / for-of / while 과 같은 반복문을 지원합니다.

1. for-loop
   Java와 같습니다.

2. for-in 문

- for-in문은 데이터 타입중 배열 뿐만 아니라.

3. for-of 문

## 함수 (function)

### 정의

일반적으로 프로그래밍 언어에서는 트정 작업을 여러번 반복해야 하는 경우, 해당 작업을 재사용 가능한 구조록 만들게 되는데 , 이때 사용하는 개념이 함수. 함수로 구현된 코드는 그 함수를 호출 함으로서 기능을 쉽게 사용가능하도록 하는것

즉 특정 기능을 수행하기 위한 코드들의 블럭이다.

형식

```js
function 함수명(매개변수1, 매개변수2) {
  let 지역변수 = 데이터;
  return 결과값;
}
```

- 함수 선언 키워드 function
- 함수명
- 매개변수 (optional)
- 실행문에 해당하는 코드 블럭
- 결과값 (optional)

예시

```js
function sum(x, y) {
  let sum = s + y;
  return sum;
}

sum(10, 20);
console.log(sum(10, 20));
```

### 함수 표현식

- _변수에 함수를 할당_ 해서 사용하는 방식

형식

```js
// 함수 표현식 예시
let 변수명 = function(매개변수1, 매개변수2){
  let 지역변수 = 매개변수1, 매개변수2 를 가지고 연산
  실행문
  return 결과값;
}

//원래 선언 방식
function (x, y) {
  let sum = x + y;
  return sum;
};

// 원래 함수 호출 방식
sum(10, 20);
```

굳이 함수 표현식이라는 개념이 나온 이유 역시 var가 일으키는 문제와 유사하다 기존의 함수 선언 박식과 선언자는 var의 겨우에는, js가 코드를 읽어 들일 때, 일단 var / function으로 되어있는 애들을 미리 메모리에 올려 둡니다.

그 의미는 일단 먼저 변수 / 함수를 사용하고 나중에 선언/정의를 하더라도 문제가 없다는 것을 의미한다.
그래서 var선언자 및 function 키워드는 hoisting라는 특징으로 설명 된다.

근데 var는 문제가 생길 수 있음을 얘기했죠. 당연히 우리는 var를 사용한다면 변수를 처음 선언할 때만 쓰는 걸로 알고 있는데 나중에 사용 가능하니까요

그렇다면, var의 문제처럼 function명 역시 동일하다면 더 밑에 정의된 애로 덮어쓰기가 되기 때문에 함수명이 겹치면 개발자가 원하는 결과값이 나오지 않을거라는 의미도 된다.

이상의 이유로 function을 let에 등록을 하게 되면 코드가 순서대로 동작한다는 점에 착안하여 함수 표현식 개념이 등장하게 되었습니다.

hoisting 때문에 함수 표현식이 등장했고, 이를 통해 담보할 수 있는 것은 _코드가 순서대로_ 실행된다는 점 입니다. 함수를 담고 있는 변수에 대한 코드 군문이 함수를 호출하는 코드 구문보다 뒤에 있다면 에러가 발생하게 될 테니까요

예시

```js
let sum(10,20);     // 오류발생
let sum(11,22);     // 오류발생

let sum =function(x, y){    //함수 표현식
  return x + y;
}
```

### Function 생성자 함수

- JS 내장 함수인 Function 함수에 매개변수와 코드 블럭을 _문자열_ 로 순서대로 전달하여 생성.

예시

```js
let sum = new Function("x", "y", "return x + y;");
let sum1 = sum(11, 22);
let sum2 = sum(22, 33);
```
