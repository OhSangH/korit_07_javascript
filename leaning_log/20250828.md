# JavaScript 내장 객체

- 내장 객체는 브라우저의 Js 엔진에 내장된 객체를 의미한다.
- 모든 Object 객체는 모든 Js의 루트 객체
- String, Number, Date, Array,Math, etc...

## Object 객체

```js
let person = new Object();

person.firstName = "John";
person.lastName = "Doe";
person.age = 20;
person.getFullName = function () {
  return this.firstName + " " + this.lastName;
};
```

해당 라인에 대한 해석을 위해서는 함수 표현식을 알아야한다.

Js에서는 함수를 변수에 저장할 수 있다.
그래서 객체명.함수면()으로 호출을 하게 되고 이 방식도 메서드라 볼 수 있다.

## String 객체

문자열을 다루는 property / 함수를 제공

1. length

- 문자열의 길이를 return한다.

```js
let txt = "abcd";
let txtLength = txt.length;
console.log(txtLength);
```

2. indexOf()

- 문자열 안에 특정 문자열이 존재하는지를 찾고, 문자열이 시작되는 index를 반환하는 method
- 문자열을 찾지 못하면 -1을 return

3. lastIndexOf()

- indexOf()와 비슷한데 문자열이 둘 이상 반복되면 제일 마지막에 발견된 문자열의 index 를 return

4. slice()

- 매개변수로 시작 위치 / 종료 위치를 줬을 때 문자열의 해당 부분을 잘라내서 return하는 method
- 매개변수의 종료 위치의 경우 해당 인덱스까지가 아닌 (종료위치 - 1)의 인덱스까지 자른다.
- 매개변수가 하나인 경우 입력받은 인덱스부터 문자열의 끝까지 잘라낸다.
- 매개변수 중 시작 위치 인덱스를 마이너스를 입력하면 마지막에서부터 입력받은 인덱스만큼 뒤로 가서 시작하여 잘라낸다.

5. substring()

- slice()랑 다 똑같은데 마이너스 인덱스가 없다.

6. substr()

- slice()랑 비슷한데 두 번째 매개변수가 한계값 미만을 지시하는게 아니라, 첫 번쨰 매개변수로부터의 문자 개수를 의미합니다.
- 마이너스 인덱스의 사용이 가능하다.

7. replace()

- 문자열 내의 특정 문자열을 지정한 문자열로 바꾸는 함수
- 특정 분자열이 복수 있을경우 첫번째 값을 교체해 준다.
- 기본적으로 대소문자를 구분하여야한다.
- `/문자열/i`를 사용하면 대소문자 구분이 필요없어진다. (i = insensitive)
- `/문자열/g`를 사용하면 일치하는 문자열 전체에 일치하는 문자열 교체 (g = global)

8. tpUpperCase(), toLowerCase()

- 모든 문자열 대문자,소문자 변경

9. concat()

- 두 개 이상의 문자열을 하나의 문자열로 합치는 메서드이다.  
  실무 사용 예시
  우리나라에서는 이름 성 형태나 / 성 이름 에서 공백 으로 구분하는 경우가 있다.
  이상의 경우에는 firstName / middleName / lastName으로 각각 변수에 데이터를 저장하고

  fullName 변수에 .concat()을 적용한 다음 출력하는 방법을 사용할 수 있습니다.

10. trim()

- 문자열 앞/뒤 공백을 모두 제거하는 함수
- DB에 공백이 있으면 조회할 떄 실패하는 경우가 있어 공백제거하고 조회하는 일이 많습니다.

11. charAt()

- 문자열에서 특정 인덱스에 해당하는 문자 하나를 반환하는 메서드

12. charCodeAt()

- 문자열에서 특정 인덱스에 해당하는 문자의 유니코드 값을 반환

13. split()

- 문자열 내의 특정 기준을 가지고 문자열을 분리하여 배열로 반환하는 메서드

14. startWith(), endWith()

- 문자열의 시작 혹은 끝이 매개변수로 전달된 값으로 이루어져 있는지 확인하는 메서드  
  실무 사례  
  stratWith("Https")를 해서 보안이 뛰어난 https로 접속했는지를 확인한다.  
  맞으면 true 틀리면 flase로 확인한다.

## Numver 객체

1. toString()

- 문자열로 바꾼다.

2. toFixed()

- 소수점 몇 번 째 짜리까지 보여 줄지를 결정하는 메서드
- 매개변수로 소수점 자리수 사용
- 반올림 적용

3. toPrecision()

- 2번과 다르게 정수와 소수를 포함해서 몇 번째 자리까지 보여줄지 결정하는 메서드

4. parseInt()

- 전역 함수로, 정수로 반환
- 문자열의 시작이 number 면 number로 반환

5. parseFloat()

- 전역 함수로 부동소수점으로 반환

## Array객체

1. toString()

- 배열 내의 element들을 `,` 기준으로 모두 결합하여 하나의 문자열로 return

2. join()

- 배열 내의 모든 문자를 매개변수로 지정한 문자를 이용하여 element들을 구분함
- toString()에서 구분하는 `,`을 지정하는 문자로 변경

3. pop()

- 배열에서 마지막 데이터를 제거하고, 마지막 데이터를 return

4. push()

- 배열에 마지막에 데이터를 주가한다.

5. shift()

- pop()과 달리 첫 번째 element를 제거하고 그 element를 return한다.

6. unshift()

- 배열의 맨 앞에 element를 추가하고, 배열의 index를 return
- 앞에 추가하는 실무 사례  
  HTML 문서 작성시 `<select>` 태그구현할 떄 예를 들어 DB에서 지역 목록 가져오고, 가져온 지역 목록을 `<select>`태그의 `<option>`태그에서 사용자에게 제일 먼저 보이는 옵션에 `선택하세요`와 같은 정보성 글이다. 이때 DB에서 `선택하세요`가 있지 않으므로 unshift()로 해당 문구를 추가한다.

7. 배열 element 변경

```js
let subs = ["국어", "수학", "영어", "자바", "자바스크립트"];
sub[0] = "파이썬";
```

8. splice()

- 새로운 element를 특정위치에 추가하는데, element를 삭제하는것도 가능하다.
  ```js
  let fruits2 = ["Banana", "Orange", "Apple", "Mango"];
  fruits2.splice(2, 0, "Lemon", "Kiwi");
  console.log(fruits2);
  ```
  splice(시작 인덱스, 삭제할 데이터 수, 추가할 데이터1, 데이터2, ...)
- 시작인덱스 : 배열에 어느위치에서 시작할 건지 정한다.
- 삭제할 데이터 수 : 시작 인덱스 위치에서 데이터를 몇개 삭제하고 추가 할 건지 확인한다.
- 추가할 데이터 : 배열에 추가 할 데이터들

9. concat()

- 2 개 이상의 배열을 하나의 배열로 결합한다.

10. slice()

- String에서와 동일하지만 배열형태로 return한다.

11. sort()

- 오름차순으로 정렬

12. reverse()

- 내림차순으로 정렬

13. filter()

- 배열에서 특정 조건을 만족하는 배열의 element만을 찾아서 새로운 배열을 return한다.
- 배열 다를 때 제일 많이 쓰고 프론트엔드에서도 자주 사용한느 method
- 특정 조건을 만족하는 데이터만 추출하는ㄴ 프로그램 작성하는 경우가 빈번한데 이때 filter()를 쓰기 때문이데ㅏ.
- 형식 : `배열명.filter(콜백함수([,index[,배열]])[,thisArg])`
- callback 함수: 배열의 각 element를 시험할 함수에 해당합니다. 조건이 true라면 element를 유지하고 아닌경우 버리게 된다.  
  여기서 유지된 element로 새로운 배열을 생성한다.
- callback 함수의 매개변수
  - element - 처리할 현재 element
  - index(optional) - 처리할 현재 element의 인덱스
  - array(optional) - 배열전체

```js
let words = [
  "부산광역시",
  "부산시",
  "서울 특별시",
  "서울",
  "경상남도 남해시",
  "남해시",
  "광주 광역시",
  "경기도 광주시",
  "오사카부 오사카시",
  "오사카",
];

let result = words.filter(function (word) {
  return word.length > 4;
});
console.log(result.toString());
```

14. map()

- 배열내의 element가 object일 때 배열에 담기 object를 새로운 형태의 object로 변환하여 배열로 return

15. reduce()

- 배열에 담긴 element를 하나씩 순회하며 callback 함수의 실행값을 누적하여 return하는 함수.
- 누적 결과 값은 숫자, 문자, 객체 모두 가능하다.
- 주로 배열 내으 ㅣelement 데이터의 합계를 구할 때 aksgdl tkdydehlqslek.
- 배열 내으 ㅣelement가 객체인 경우 누적 값을 구하고자 하는 object의 property를 참조해서 씁니다.

```js
let scores = [40, 100, 1, 5, 25, 10];
let sum = scores.reduce(function (total, currentValue) {
  return total + currentValue;
});
console.log(sum);
```

reduce() method 내의 callback 함수는 4개의 매개변수를 가질 수 있습니다.(주고 2개만 사용하며 나머지는 element입니다.)

- 1번 매개변수 : accumulator(누적값)
- 2번 매개변수 : currentValue(배열의 현재 element)
- 3번 매개변수 : currentIndex(현재 Index넘버)
- 4번 매개변수 : Array(배열)

## Set 객체

1. Set 생성자

```js
let mySet = new Set();
```

2. add()

- 데이터를 추가한다.

3. has()

- 특정 데이터가 있는지 확인한다.

4. delete()

- 특정 데이터를 삭제한다.

5. clear()

- 저장되어있는 모든 데이터를 삭제한다.

6. forEach()

- 저장돼 있는 모든 데이터를 읽는다.

## Map 객체

1. Map 생성자

```js
let userMap = new Map();
```

2. set()

- Map 객체에 데이터를 저장한다.

2. get()

- 키를 이용하여 값을 가져온다.

4. has()

- 특정 키의 값이 저장 되어있는지 확인한다.

5. delete()

- 특정 데이터를 삭제한다.

6. clear()

- 저장돼있는 모든 데이터를 삭제한다.

7. forEach()

- 저장돼 있는 모든 데이터를 읽는다.

### JavaScript Object vs JavaScript Map

1. Object는 key를 String으로 지정해야 하지만 Map은 다른 타입도 가능하다.
2. Object는 몇 개의 데이터가 담겨있는지 수동 계산해야 하지만 map은 .size를 이용하여 알 수 있다.
3. Object는 저장된 데이터를 for-in으로 읽었을 때 순서를 보장하지 않지만 Map은 데이터를 저장한 순서대로 읽어옵니다.

## JSON객체

- 데이터를 저장하거나 정송할 때 많이 사용되는 경량의 데이터 교환 형식
- 다수의 플랫폼에 사용된다.

1. 서버와 클라이언트간의 데이터 전송 시 많이 사용
2. JavaScript의 SObject 객체 표기법과 유사하다.
3. JSON 데이터는 JavaScript JSON 객체의 parse() method를 이용하면 JavaScript Object 객체로 변환하여 사용 가능하다.
4. 프로그래밍 언어와 상광없이 사용할 수 있는 데이터 교환 방식
5. 대부분의 언어에서 Json 데이터를 처리할 수 있는 라이브러리 제공(Java에서의 Gson)

### 중요 내장 함수 목록

1. JSON.stringify(Object명)
   - 데이터를 서버로 전송하기 위해서 데이터 형태를 문자열로 변환(이유 : 가벼워서)해준다.
     여기서 JavaScript 객체를 문자열로 변환해줍니다.
2. JSON.parse(JSON명)
   - 서버로부터 응답받은 JSON 데이터를 Object객체로 변환해 줍니다.

## 윈도우 함수

Window객체는 전역 객체입니다. 현재는 브라우저라고 생각해도 된다.

1. alter()

- 윈도우 화면에 경고 메시지를 출력

```js
alert("이것은 alter창입니다.");
```

2. confirm()

- return type boolean

```js
confirm("정말 삭제하시겠습니까?");
```

3. prompt()

- 값을 입력 받는다.

```js
let txt = prompt("비밀번호를 입력하세요.");
if (txt === null) {
  // 취소버튼을 눌렀을 때 의 로직
} else if (txt === "") {
  // 비밀번호가 일치할 때 로직
} else if (txt === "") {
  // 비밀번호가 다를때 로직
}
```

4. open()

- 윈도우 새창 / 새 탭으로 지정한 url을 오픈하는 함수

5. setTimeout() / clearTimeout()

- setTimeout() 함수는 두 번째 매개변수로 지정한 시간 간격 이후에 첫 번째 매개변수에 정의한 함수를 실행 시킴. callback 개념을 이해하여야 한다.

- clearTimeout() - setTimeout() 함수에서 정의한 함수가 실행되지 않았을 때와 setTimeout()의 콜백 함수를 실핼 시키는 것을 중지할 때 사용한다.

- 밀리초를 사용한다.

# JavaScript 고급 문법(이지만 front에서 그냥 다 쓰는)

## Default Function Parameter

- 함수를 호출할 때 예를 들어, `function(massage){return 어쩌고};` 메세지가 비어있는 상태가 되면 호출 단계에서 argment가 없기 때문에 오류(undefined)가 발생합니다. 만약에 매개변수가 함수 내에서 특정 기능을 구현하기 위해서 반드시 요구 된다면, _아무런 값이 없을 경우_ 함수를 호출 할 때마다 체크를 해야한다.

```js
function say(message) {
  if (massage !== undefined) {
    console.log(massage);
  } else {
    console.log("매개변수 입력이 안됬습니다.");
  }
}
```

Default Function Parameter를 지정하게 되면, argument. 없이 함수를 호출 했을 때 미리 설정해둔 기보값으로 함수를 호출하여 오류가 발생하지 않게끔 하는 사전 작업

```js
function sa(massage = "매개변수가 입력되지 않았습니다.") {
  console.log(massage);
}

say();
```

## Rest Parameter

일반적인 함수 선언식으로 함수에 따라 몇개의 argument가 요구되는지 미리 선언합니다. 매개변수 2개 짜리로 정의하면 함수 호출 시에 2개의 argument를 요구하고, 4 개짜리를 정의하면 함수 호출 할 때 4개의 argument를 요구 하게된다.  
그러나 3개 짜리를 쓰고 싶으면 어떡해야하나 문제가 있다.

```js
function sum(x1, x2) {
  return x1 + x2;
}

sum(5, 7);

function sum(x1, x2, x3, x4) {
  return x1 + x2 + x3 + x4;
}
sum(5, 7, 8, 10);
```

여전히 3개짜리 연산을 불가능 해서 sum(1,2,3,0); 같은 꼼수로만 가능하다.
여기서 Rest Parameter를 사용하면 몇개의 매개변수가 들어오는지 모르는 상황에 유용하다.

```js
function(....args){
  let total =0;
  for(let x if args){
    total += x;
  }
  return total;
}
```

## Arrow Function(Lambda Expression의 JS ver.)
기존의 함수 표현 방식들
1. 함수 선언식
```js
function hello(name) {
  return 'hello ' + name;
}
```
2. 함수 표현식
```js
const hello2 = function(name) {
  return 'hello ' + name;
}
```
hoisting 여부로 인해 # 1, # 2 방법이 생겨났습니다.

화살표 함수는 함수를 정의하는 비교적 최근 방법입니다(저희는 람다에서 배웠지만 여기서 훨씬 많이 써먹습니다). 화살표 함수를 사용해서 함수를  정의하면 구문이 짧아진다는 장점이 있습니다. 단점은 람다에서 봤던 것처럼 너무 복잡한 로직을 구현하기는 힘들다는 점입니다.

3. 화살표 함수
```js
// full form
const hello3 = (name) => {return 'Hello ' + name};

// 매개변수가 하나라면 소괄호(())를 생략할 수 있다
const hello4 = name => {return 'Hello ' + name};

// 실행문이 한 줄이라면 return / 중괄호({})를 생략할 수 있다
const hello5 = name => 'Hello ' + name;

// 매개변수가 없다면 빈 소괄호를 사용함.
const hello6 = () => 'Hello, there';
```
## Template Literals
```js
// 1. 기존 작성 방식
function hello(name) {
  console.log('Hello ' + name + '. 환영합니다!');
}

// 2. 템플릿 리터럴 적용 방식
function hello2(name) {
  console.log(`Hello ${name}. 환영합니다!`);
}
```
2의 장점은 중간에 ++ 기호넣는다고 오류 발생할 확률이 적다는 점입니다.
단점은 대충 보면 얘가 ''인지 ``인지 구분할 방법이 없다는 겁니다.
그래서 차라리 중간에 ${}가 있으면 템플릿 리터럴이 적용되었다고 보는게 여러분들의 정신건강에 좋습니다.

01_js_applied.html / .js

## Object Literal Syntax Extension
```js
// 1. 기존 방식
let fName = 'Josh';
let lName = 'Smith';

let person = {
  fName: fName,  // 앞은 person의 property고 뒤는 433번 라인의 변수죠.
  lName: lName,
}

// 2. Object Literal
let type = 'student';
let score = {
  [type]: 'Josh',
  score: 92,
}
```
2. 번에서 Object의 key에 []가 있다는 점을 확인할 수 있습니다. Js 객체의 key를 []로 감싸게 됐을 때는 '할당된 변수 값'을 의미하게 됩니다.
이상의 장점으로는 Js 객체의 key를 _동적으로_ 생성 가능합니다.

## Spread Operator

- 배열, 문자열 등 반복 가능 객체 형태의 데이터를 element로 하나하나로 분해해서 사용할 수 있도록 함.

## Object Destructuring(객체 구조 분해)

## Array Destructuring(배열 구조 분해)

# JS HTML DOM

- DOM(Document Object Model)
- JS 또는 HTML 문서의 모든 요소에 접근하여 변경할 수 있ㅅ브니다. 간단하게는 `<table>`태그 내의 `<td>` 요소를 추가할 수 있을 겁니다.

1. 모든 HTML element
2. HTML 태그의 속성
3. HTML CSS 스타일
4. HTML element 및 속성ㅇ르 제거
5. 새로운 HTML element 및 속성을 추가
6. 페이지 내에 존재하는 모든 HTML 이벤트에 대한 반응
7. 새로운 HTML 이벤트 추가

## DOM Element

JS 에서 HTML element에 대한 다양한 제어를 위해 가ㅏㅇ 머저 할 일은 HTML element에 대한 접근입니다. JS 상에서 HTML 요소를 찾는 방법은,

1. id 값을 통해
2. 태그명을 통해
3. class 명을 통행
4. CSS 선택자 개념을 통해
   위와 같은 방법들로 찾을 수 있다.

- HTML element의 id로 찾기
  - HTML 태그의 id 속성은 고유값이기 때문에 단일한 결과가 나온다.
  - 만약에 id가 정확하다면 JS 객체의 형태로 HTML element가 return된다.
  - 일치하는 id가 없다면 null이 return된다.

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM element</title>
  </head>
  <body>
    <input type="text" id="userid" />
    <p>태그명을 사용해서 HTML 요소를 찾습니다. document.getElementById</p>
    <script>
      let element = document.getElementById("userid");
      console.log(element);
    </script>
  </body>
</html>
```

- 태그명을 통한 추출

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM tag</title>
  </head>
  <body>
    <p>HTML 요소에 대한 접근</p>
    <p>
      태그명을 사용하여 HTML element를 추출합니다. <br />
      document.getElementByTagName()
    </p>
    <script>
      let element = document.getElementsByTagName("p");
      console.log(element);
    </script>
  </body>
</html>
```

- id 값을 통한 추출과 태그명을 통한 추출에서의 차이점은 id는 고유값인데 반해 태그는 한 HTML에 복수로 있을수 있으므로, return타입이 JS 객체 하나짜리가 아니라, JK 객체를 element로 하는 배열이 return된다는 점이다.
- 이를 명확히 확인하기 위해서 method 명을 보시면
- getEelement's'ByTagName이라고 명시되어있는 점을 앟 수 있습니다.

-클래스명을 이용한 HTML 요소 찾기

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM tag</title>
  </head>
  <body>
    <p class="para">
      여기는 클래스명을 통한 HTML 요소를 찾겠습니다. <br />
      document.getElementByClassName('para');
    </p>
    <p class="para">하나 더 넣겠습니다.</p>
    <b class="para"> 이건 다른태그의 동일한 클래스 명입니다. </b>
    <script>
      let classElement = document.getElementsByClassName("para");
      console.log(classElement);
    </script>
  </body>
</html>
```

- CSS 선택자를 이용한 HTML 요소 추출

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM tag</title>
  </head>
  <body>
    <p class="para">여기는 클래스명을 통한 HTML 요소를 찾겠습니다.</p>
    <p class="para">하나 더 넣겠습니다.</p>
    <b class="para"> 이건 다른태그의 동일한 클래스 명입니다. </b>
    <p class="para">
      CSS 선택자를 이용하여 HTML element를 추출합니다. <br />
      document.querySelectorAll('p.para');
    </p>
    <script>
      let selectorResult = document.querySelectorAll("p.para");
      console.log(selectorResult);
    </script>
  </body>
</html>
```

위 코드의 경우 b.para의 요소는 빠지고 p.para의 요소만 추출 된다.

## DOM Attribute

## HTML 내용 변경

1. innerHTML

   - HTML의 특정 위치에 새로운 HTML을 삽일할 때 사용.

2. innerText
   - 1.과 비슷하지만 텍스트 내용만 삽입 가능

## DOM event(클릭 이벤트 등)

웹페이지를 이용하면 웹 화면과 사용자 사이에 상호작용이 나타납니다. 예를 들어

1. 버튼을 클릭한다든지
2. 마우스를 스크롤한다든지
3. 검색을 위해 검색키워드를 input창에 입력한다는지 하는 행동
   이상의 모든 상호작용을 event라고 합니다.

### click 이벤트(onclick) - react에서는 onClick

마우스 좌클릭 할 때 발생하는 이벤트 입니다. 검색/ 저장과 같은 버튼을 클리하면, 이 때 클리 이벤트가 발생합니다.

대표적인 예로 `<button>` 요소에 클릭 이벤트가 일어나는지르 감시하고, 클릭 이벤트가 일어나는 순간 특정 함수를 실행 시켜야 한다.

이때 `<button>` 태그 내의 onclick 속성을 이용하여 처리할 수 있다.

- 검색 버튼을 클릭하면 검색 기능이 실행되어 화면에 검색 결과를 출력
- 저장 버튼을 클릭하면 사용자가 입력한 데이터를 서버로 보내고 DB에 저장
- 메뉴 버튼을 클릭하면 메뉴 기능이 추가되어 화면에 출력

### change 이벤트(onchange) - react onChange

- 값이 변경되었을 때 발행하는 이벤트
- 대표적을 `<select>` ,`<input type = "checkbox">`, `<input type = "radid">`에서 발생한다.

### key 이벤트 (onkeydown, onkeyup,onkeypress)

key 이벤트는 사용자가 입력창에 (`<input>`태그에서) 키보드를 입력할 때 발생.
사용자가 키를 입력하면 keydown -> keypress -> keyup의 순서로 이루어 집니다.

input type = "text" 에 keydown / keyup / keypress 이벤트를 모두 받을 수 잇도록 설정하고, 순서를 검증하겠습니다.

# JS 주요 Web APIs

## LocalStorage / SessionStorage

까지 하고 Todo List js 만들기

```

```
